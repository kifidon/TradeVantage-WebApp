#define MA_1_EA_H
//+------------------------------------------------------------------+
//|                                                      MA_Cross_EA |
//|                        Generated by MetaEditor                   |
//+------------------------------------------------------------------+
#property strict
#include <TradeVantage_Util.mqh>

// Input parameters
input int MAPeriod = 12;                // MA Period
input int MAShift = 6;                  // MA Shift
input double LotSize = 0.01;            // Lot Size
input double EntryDistance = 0;       // Distance for trade entry (in $)
input double ExitDistance = 0;        // Distance for trade exit (in $)
input double TakeProfit = 1000;       // Take Profit in $
input int MagicNumber = 123456;         // Magic Number for EA
input double MULT = 1.5;                   // Multiplier for lot size  
input double SLOPE = 1.0;                // Trend Strength
input int SLOPE_PERIOD = 100;         // Slope Period
input int SLOPE_LENGTH = 32;          // Slope Length

#define TIMER_PERIOD TIMER_INTERVAL
#define VALID_ACCOUNT ACCOUNT_NUMBER

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    // Initialization code
    Print("Initializing EA...");
    if (MQLInfoInteger(MQL_TESTER) && MQLInfoInteger(MQL_VISUAL_MODE) && !DEBUG) {
        Alert("This EA does not support Visual Mode.\nPlease disable Visual Mode in the Strategy Tester and restart.");
        return INIT_FAILED;
    }
    if(!(DEBUG)){
        EventSetTimer(TIMER_INTERVAL);
    }
    return(EA1_MA_OnInit());
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    Print("Deinitializing EA...");
    EventKillTimer();
    if (!DEBUG)
        RemoveIndicatorsOnTester();

}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    bool tradeMade = false;

    EA1_MA_OnTickDashboard();


    double MA_Value = iMA(NULL, 0, MAPeriod, MAShift, MODE_SMA, PRICE_CLOSE, 1);

    double close = Close[1];
    double open = Open[1];
    int buyTrades = CountTrades(OP_BUY);
    int sellTrades = CountTrades(OP_SELL);
    
    // --- BUY ENTRY ---
    if (close > MA_Value + EntryDistance && open < MA_Value && buyTrades == 0 && previousBars != Bars && lineOfBestFit(SLOPE_PERIOD, SLOPE_LENGTH) ==1 )
    {
        if(DEBUG)
        Print("BUY SIGNAL -> Close[1]: ", close,
              ", Open[1]: ", open,
              ", MA: ", MA_Value,
              ", EntryDistance: ", EntryDistance,
              ", BuyTrades: ", buyTrades);

        CloseAllTrades(OP_SELL);
        CheckLastClose();
        OpenTrade(OP_BUY);
        TOTALBUY_trades++;
        tradeMade = true;
    }
    // --- SELL ENTRY ---
    else if (close < MA_Value - EntryDistance && open > MA_Value && sellTrades == 0 && previousBars != Bars && lineOfBestFit(SLOPE_PERIOD, SLOPE_LENGTH) ==1 )
    {
        if(DEBUG)
        Print("SELL SIGNAL -> Close[1]: ", close,
              ", Open[1]: ", open,
              ", MA: ", MA_Value,
              ", EntryDistance: ", EntryDistance,
              ", SellTrades: ", sellTrades);

        CloseAllTrades(OP_BUY);
        CheckLastClose();
        OpenTrade(OP_SELL);
        TOTALSELL_trades++;
        tradeMade = true;
    }

    // --- BUY EXIT ---
    if (close < MA_Value - ExitDistance && buyTrades > 0)
    {
        if(DEBUG)
        Print("BUY EXIT -> Close[1]: ", close,
              ", MA: ", MA_Value,
              ", ExitDistance: ", ExitDistance,
              ", BuyTrades: ", buyTrades);

        CloseAllTrades(OP_BUY);
        tradeMade = true;
    }

    // --- SELL EXIT ---
    if (close > MA_Value + ExitDistance && sellTrades > 0)
    {
        if(DEBUG)
        Print("SELL EXIT -> Close[1]: ", close,
              ", MA: ", MA_Value,
              ", ExitDistance: ", ExitDistance,
              ", SellTrades: ", sellTrades);

        CloseAllTrades(OP_SELL);
        tradeMade = true;
    }

    // --- NO TRADE ---
    // if (!tradeMade && DEBUG)
    // {
    //     if (!(close < MA_Value - EntryDistance))
    //         Print("NO BUY: close not below MA - EntryDistance -> close: ", close, ", threshold: ", MA_Value - EntryDistance);
    //     if (!(open > MA_Value + EntryDistance))
    //         Print("NO BUY: open not above MA + EntryDistance -> open: ", open, ", threshold: ", MA_Value + EntryDistance);
    //     if (buyTrades != 0)
    //         Print("NO BUY: Existing BUY trades present -> buyTrades: ", buyTrades);
    //     if (previousBars == Bars)
    //         Print("NO BUY/SELL: Same bar -> previousBars == Bars: ", Bars);

    //     if (!(close > MA_Value + EntryDistance))
    //         Print("NO SELL: close not above MA + EntryDistance -> close: ", close, ", threshold: ", MA_Value + EntryDistance);
    //     if (!(open < MA_Value - EntryDistance))
    //         Print("NO SELL: open not below MA - EntryDistance -> open: ", open, ", threshold: ", MA_Value - EntryDistance);
    //     if (sellTrades != 0)
    //         Print("NO SELL: Existing SELL trades present -> sellTrades: ", sellTrades);
    // }else if (DEBUG)
    // {
    //     Print("Trade made: ", tradeMade);
    // }
    if (previousBars != Bars)
    {
        previousBars = Bars;
        UpdateDateValues();
    }
}

//+------------------------------------------------------------------+
//| Function to open a trade                                         |
//+------------------------------------------------------------------+
void OpenTrade(int cmd)
{
    int ticket = -1;
    int errorCode = 0;
    double openPrice = (cmd == OP_BUY) ? Ask : Bid;
    double tpPrice = 0;
    
    do
    {
        // Calculate the TP price based on dollar target
        double tickValue = MarketInfo(Symbol(), MODE_TICKVALUE);
        double tickSize = MarketInfo(Symbol(), MODE_TICKSIZE);
        double profitPoints = (TakeProfit / (currentLotsize * tickValue)) * tickSize;

        if (cmd == OP_BUY)
            tpPrice = NormalizeDouble(openPrice + profitPoints, Digits);
        else
            tpPrice = NormalizeDouble(openPrice - profitPoints, Digits);

        if (DEBUG)
        {
            Print("Trying to open trade: ", cmd == OP_BUY ? "BUY" : "SELL",
                  ", Lot Size: ", DoubleToString(currentLotsize, 4),
                  ", TP price: ", DoubleToString(tpPrice, Digits));
        }

        ticket = OrderSend(Symbol(), cmd, currentLotsize, openPrice, 3,
                           0, tpPrice, "", MagicNumber, 0, clrNONE);


        if (ticket < 0)
        {
            errorCode = GetLastError();
            Print("OrderSend failed. Error: ", errorCode);

            if (errorCode == 134)  // Not enough money
            {
                currentLotsize = currentLotsize / MULT;

                if (currentLotsize < LotSize)
                {
                    Print("Lot size too small to continue retrying. Aborting trade.");
                    break;
                }

                Sleep(500); // Slight delay before retry
            }
            else
            {
                // For other errors, stop retrying
                break;
            }
        }

    } while (ticket < 0 && errorCode == 134);
}

//+------------------------------------------------------------------+
//| Function to close all trades of a specific type                  |
//+------------------------------------------------------------------+
void CloseAllTrades(int cmd)
{
    for (int i = OrdersTotal() - 1; i >= 0; i--)
    {
        if (OrderSelect(i, SELECT_BY_POS) && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
            if (OrderType() == cmd)
            {
                double profit     = OrderProfit(); // Built-in function to check trade profit/loss
                OrderClose(OrderTicket(), OrderLots(), OrderType() == OP_BUY ? Bid : Ask, 3, clrNONE);
                countTotalProfits();

                string dailyProfitText = "This Day's Profit: " + DoubleToString(TOTALDAY_profit, 2);
                string WeeklyProfitText = "This Week's Profit: " + DoubleToString(TOTALWEEK_profit, 2);
                string MonthlyProfitText = "This Month's Profit: " + DoubleToString(TOTALMONTH_profit, 2);

                // Update the labels with the formatted text
                UpdateLabel("This Day's Profit", dailyProfitText);
                UpdateLabel("This Week's Profit", WeeklyProfitText);
                UpdateLabel("This Month's Profit", MonthlyProfitText);

                if(profit > 0) {
                    currentLotsize = LotSize;
                } else if(profit < 0) {
                    currentLotsize *= MULT;
                } else {
                    Print("Trade closed at break-even.");
                }
            }
        }
    }
}



//+------------------------------------------------------------------+
//| Function to count open trades of a specific type                 |
//+------------------------------------------------------------------+
int CountTrades(int cmd)
{
    int count = 0;
    for (int i = OrdersTotal() - 1; i >= 0; i--)
    {
        if (OrderSelect(i, SELECT_BY_POS) && OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
            if (OrderType() == cmd)
            {
                count++;
            }
        }
    }
    return count;
}

void OnTimer()
{
    if(AuthenticateSubscription() == 0){
        return;
    }
    EventSetTimer(TIMER_INTERVAL);

}

void CheckLastClose()
{
   int totalOrders = OrdersHistoryTotal();

    if (totalOrders > 0)
    {
        // Check only the most recent closed trade
        int i = totalOrders - 1;

        if (OrderSelect(i, SELECT_BY_POS, MODE_HISTORY) &&
            OrderMagicNumber() == MagicNumber &&
            OrderSymbol() == Symbol() &&
            OrderCloseTime() > 0)
        {
            double profit = OrderProfit();

            if (profit > 0)
            {
                currentLotsize = LotSize;
            }
        }
    }
}